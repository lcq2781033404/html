一.概述
面向对象的开发模式不同于面向过程。面向过程的开发是分析完成一个功能需要的操作步骤，而面向对象的开发是分析完成一个功能需要哪些对象，以及每一个对象
应该具备的属性和方法。面向对象是面向过程的高度封装。

二.面向对象的特性
1.封装性
2.继承性
3.多态性（抽象）

三.创建对象的模板
在js中，创建对象的模板是构造函数，而在其他语言中，创建对象的模板是类。
创建构造函数：
function Student(name, subject, score) {
  this.name = name;
  this.subject = subject;
  this.score = score;
  this.printScore = function() {
    ...
  }
}

var zhangsan = new Student('zhangsan', 'english', 66);

四.创建对象的方式
1.使用new Object()
var hero = new Object();
hero.name = 'zs';
hero.blood = 100;
hero.attack = function() {
  ...
}
...

2.使用对象字面量（创建单个对象）
var hero = {
  name: 'zs',
  blood: 100,
  attack: function() {
    ...
  }
};

3.工厂方法（通过函数创建多个对象）（弊端：创建出的对象都是object类型的，以后我们需要有自己的类型，比如英雄都是英雄类型，学生都是学生类型）
function createHero(name, blood) {
  var o = new Object();
  o.name = name;
  o.blood = blood;
  o.attack = function() {
    ...
  };
  return o;
}

4.构造函数方法（强烈推荐）
构造函数名字的第一个字母要大写！！！！！
function Student(name, subject, score) {
  this.name = name;
  this.subject = subject;
  this.score = score;
  //多个对象，会存储多个printScore方法
  this.printScore = function() {
    ...
  }
}

var zhangsan = new Student('zhangsan', 'english', 66);

五.静态成员和实例成员
1.静态成员：
可以直接使用对象来调用属性和方法
比如：
var MyMath = {
  PI: 3.14,
  Min: function() {...}
};
MyMath.PI;
MyMath.Min();
2.实例成员：
需要先通过构造函数实例一个对象并通过该对象调用属性和方法。

六.构造函数原型
function Student(name, subject, score) {
  this.name = name;
  this.subject = subject;
  this.score = score;
  //多个对象，会存储多个printScore方法
  this.printScore = function() {
    ...
  }
}

var zhangsan = new Student('zhangsan', 'english', 66);

在使用上面的构造函数实例对象的时候，每实例一个对象，就会在内存中创建开辟一个空间存储该对象对应的printScore方法，这样是很浪费内存空间的。
使用构造函数原型就可以解决上面的问题：
每一个构造函数都有一个属性：原型对象（prototype）
function Student(name, subject, score) {
  this.name = name;
  this.subject = subject;
  this.score = score;
 //方法不在构造函数中声明了
}
//Student.prototype指向了Student构造函数的原型
Student.prototype.printScore = function() {
  ...
}
//通过构造函数创建的所有对象都可以访问构造函数原型对象中的成员
var zhangsan = new Student('zhangsan', 'english', 66);
zhangsan.printScore();
 
总结：
1.一般情况下，对象的属性在构造函数中设置。
2.一般情况下，对象的方法在构造函数的原型中设置（节省内存）。
eg. Student.prototype = {
  constructor: Student,//注意这个是一定要有的，否则后面再获取对象的constructor属性的时候就不是构造函数类型了
  sayHi: function() {
    ...
  },
  printScore: functuion() {
    ... 
  },
  ...
};
3.要先设置原型对象的属性，在创建对象，才能访问原型对象中的成员。
