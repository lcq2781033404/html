## 一. 强类型语言与弱类型语言
### 1. 强类型语言
强类型语言不允许改变变量的数据类型，除非进行强制类型转换。  
比如java和c#都是强类型语言。
### 2. 弱类型语言
弱类型语言中，变量可以被赋予不同的类型。  
比如js就是弱类型语言。

## 二. 静态类型语言与动态类型语言
### 1. 静态类型语言
在编译阶段确定所有变量的类型  
比如c，c++
### 2. 动态类型语言
在执行阶段确定所有变量的类型  
比如js  
TypeScript是一门强类型静态语言

## 三. TypeScript安装及简单使用
### 1. 初始化项目
npm init，生成package.json文件  
### 2. 安装webpack
npm install webpack webpack-cli webpack-dev-server -g  
### 3. 全局安装typescript
npm install typescript -g  
输入 tsc -h 可以查看typescript的帮助信息  
### 4. 创建typescript配置项
tsc --init，生成tsconfig.json文件
### 5. 编译ts文件
typescript文件后缀名是.ts，需要编译成js文件运行，输入命令 tsc xxx.ts 即可把xxx.ts文件编译成js文件
### 6. 安装ts-loader
npm install ts-loader typescript -D  这里需要再次本地安装一下typescript  

## 四. 基本类型
### 1. 类型注解
作用：相当于强类型语言中的类型声明
语法：(变量/函数):type
### 2. 元组
元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。
```javascript
// Declare a tuple type
let x: [string, number];
// Initialize it
x = ['hello', 10]; // OK
// Initialize it incorrectly
x = [10, 'hello']; // Error
```
### 3. 枚举
枚举类型可以为一组数值赋予友好的名字。（一组有名字的常量集合）
```javascript
enum Color {Red, Green, Blue}
let c: Color = Color.Green; // c:1
```
默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：
```javascript
enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green; // c:2
```
### 4. any
标记为any的数据可以是任何类型，适用于对数据类型不是很确定的情况：
```javascript
let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // okay, definitely a boolean
```
### 5. 类型断言
类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 
类型断言有两种形式。 其一是“尖括号”语法：
```javascript
let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;
```
另一个为as语法
```javascript
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;
```
## 五. 接口
### 1. 介绍
TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是对类型做出约束。 
比如下面我使用接口对函数参数类型做出约束：
```javascript
interface LabelledValue {
  label: string;
}
function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}
let myObj = {size: 10, label: "Size 10 Object"}; // 传入的参数可以比接口约束的参数多，但是一定要满足接口的约束条件
printLabel(myObj);
```
### 2. 可选属性
默认情况下接口约束的属性都是必须的，如果想要某些属性是可选的，在变量名后面加上？即可：
```javascript
interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  let newSquare = {color: "white", area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({color: "black"});
```
### 3. 只读属性
一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:
```javascript
interface Point {
    readonly x: number;
    readonly y: number;
}

let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
```
### 4. 使用接口描述函数
为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。
```javascript
interface SearchFunc {
  (source: string, subString: string): boolean;
}
let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  let result = source.search(subString);
  return result > -1;
}
```
### 5. 使用接口描述类
接口描述类使用implememts关键字，可以在接口中描述一个方法，在类里实现它：
```javascript
interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
```
### 6. 接口继承接口
和类一样，接口也可以相互继承：
```javascript
interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square = <Square>{}; // 这里用到了类型断言
square.color = "blue";
square.sideLength = 10;
```
### 7. 接口继承类
当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被**这个类或其子类**所实现（implement）。
```javascript
class Control {
    private state: any;
}

interface SelectableControl extends Control {
    select(): void;
}

class Button extends Control implements SelectableControl {
    select() { }
}

class TextBox extends Control {
    select() { }
}

// 错误：“Image”类型缺少“state”属性。
class Image implements SelectableControl {
    select() { }
}
```
### 8. 混合接口
一个对象可以同时做为函数和对象使用，并带有自己的属性。实现这种对象的接口叫混合接口：
```javascript
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = <Counter>function (start: number) { return 'a string' };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
```
## 六. 类
### 1. 基础使用
下面是一个使用类的基本例子
```javascript
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

let greeter = new Greeter("world");
```
### 2. 继承
继承有一点要注意的就是：派生类如果包含了一个构造函数，它 必须调用 super()，相当于会执行基类的构造函数。 而且在构造函数里访问 this的属性之前一定要调用 super()。 
```javascript
class Animal {
    name: string;
    constructor(theName: string) { 
      this.name = theName;
    }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { 
      super(name); 
    }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { 
      super(name); 
    }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}

let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");

sam.move();
tom.move(34);
```
### 3. 公共，私有与受保护的修饰符
